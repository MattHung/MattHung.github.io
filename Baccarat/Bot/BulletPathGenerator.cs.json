using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Xml;
using Widget;

namespace ClientSocket
{
    public class BulletPathGenerator
    {
        class CannoLocation
        {
            public string Name;
            public double BuildCount;
            public int TotalCount;
            
            public int X;
            public int Y;
            public int Fire_degree_min;
            public int Fire_degree_max;

            public CannoLocation(string name, int x, int y, int fire_degree_min, int fire_degree_max)
            {
                BuildCount = 0;
                TotalCount = 0;
                Name = name;
                X = x;
                Y = y;
                Fire_degree_min = fire_degree_min;
                Fire_degree_max = fire_degree_max;
            }
        }

        class CannonPathBundle
        {
            public class BulletPathBundle{
                public List<List<BulletPathInfo>> Paths = new List<List<BulletPathInfo>>();
            }

            public Dictionary<string, BulletPathBundle> PathByBullet = new Dictionary<string, BulletPathBundle>();
        }

        public static  Rectangle Bound = new Rectangle(0, 0, Form1.SCENE_FARM_WIDTH, Form1.SCENE_FARM_HEIGHT);

        public const string FILE_BULLETPATH = "../Config/BulletPath.xml";
        
        private static CriticalSection m_critical_progress = new CriticalSection();

        private static List<CannoLocation> m_cannons = new List<CannoLocation>();        
        private static Dictionary<string, double> m_buildProgress = new Dictionary<string, double>();

        private static Dictionary<string, CannonPathBundle> m_buildResult = new Dictionary<string, CannonPathBundle>();

        public static Dictionary<string, double> BuildProgress
        {            
            get
            {
                Dictionary<string, double> result = new Dictionary<string, double>();

                m_critical_progress.Enter();
                foreach (KeyValuePair<string, double> item in m_buildProgress)
                    result.Add(item.Key, item.Value);
                m_critical_progress.Leave();

                return result;
            }
        }

        public static void init()
        {            
            if (!File.Exists(FILE_BULLETPATH))
                return;

            JObject jobj = JObject.Parse(File.ReadAllText(FILE_BULLETPATH));

            jobj = jobj.GetValue("save") as JObject;

            foreach (JObject cannon in jobj.GetValue("CannonLocation"))
            {
                
                m_cannons.Add(new CannoLocation(cannon.GetValue("-Name").ToString(),
                            Convert.ToInt32(cannon.GetValue("-X")), Convert.ToInt32(cannon.GetValue("-Y")),
                            Convert.ToInt32(cannon.GetValue("-fire_degree_min")), Convert.ToInt32(cannon.GetValue("-fire_degree_max"))));
            }
        }

        private static void BuildByBullet(CannoLocation location, string bullet_name, int speed, int speed_sample_count)
        {
            int total_count = speed_sample_count * ((location.Fire_degree_max - location.Fire_degree_min) + 1);
            location.TotalCount = total_count;

            m_critical_progress.Enter();
            if (!m_buildProgress.ContainsKey(location.Name))
                m_buildProgress.Add(location.Name, 0);
            m_critical_progress.Leave();

            m_buildResult[location.Name].PathByBullet.Add(bullet_name, new CannonPathBundle.BulletPathBundle());

            for (int i = location.Fire_degree_min; i <= location.Fire_degree_max; i++)
            {
                BuildInternal(location.Name, bullet_name, location.X, location.Y, i, speed, Bound);
                location.BuildCount++;

                m_critical_progress.Enter();                
                m_buildProgress[location.Name] =  location.BuildCount / location.TotalCount;
                m_critical_progress.Leave();
            }
        }

        private static void BuildByCannon(Object state)
        {
            CannoLocation cannon = (CannoLocation)state;

            BuildByBullet(cannon, "bullet", 1, 1);
        }

        private static void ResetFile()
        {
            if (!File.Exists(FILE_BULLETPATH))
                return;

            JObject jobj = JObject.Parse(File.ReadAllText(FILE_BULLETPATH));

            JObject jobj_save = jobj.GetValue("save") as JObject;

            foreach (JToken element in jobj_save.Children().ToArray())
            {
                if (!element.Path.Contains("CannonLocation"))
                    element.Remove();
            }

            File.WriteAllText(FILE_BULLETPATH, jobj.ToString());

            m_critical_progress.Enter();
            m_buildProgress.Clear();
            m_critical_progress.Leave();

            m_buildResult.Clear();
        }

        public static void Build(Object stateInfo)
        {
            ResetFile();

            for (int i = 0; i < m_cannons.Count; i++)
            {
                m_buildResult.Add(m_cannons[i].Name, new CannonPathBundle());
                m_cannons[i].BuildCount = 0;
                BuildByCannon(m_cannons[i]);
            }

            Flush();
        }

        static string getKey(BulletPathInfo path)
        {
            return string.Format("{0}_{1}_{2}_{3}_{4}_{5}", path.Angle_Incident, path.Angle_Reflection, path.Source.X, path.Source.Y, path.Destination.X, path.Destination.Y);
        }
        
        private static void BuildInternal(string cannon_name, string bullet_name, int start_x, int start_y, int degree, int speed, Rectangle bound)
        {
            int in_speed = speed;
            int in_degree = degree;

            Dictionary<string, double> pathlist = new Dictionary<string, double>();

            Func<BulletPathInfo, bool> checkDuplicate = (BulletPathInfo in_path) =>
            {
                string key = getKey(in_path);

                if (pathlist.ContainsKey(key))
                    return true;

                return false;
            };

            BulletPathInfo path = new BulletPathInfo();

            List<BulletPathInfo> full_path = new List<BulletPathInfo>();

            while(true)
            {
                path = Mathematics.GetBulletPath(start_x, start_y, degree, speed, bound);

                path.Destination.X = Math.Round(path.Destination.X);
                path.Destination.Y = Math.Round(path.Destination.Y);

                //Console.WriteLine(string.Format("s:{0},{1}  d:{2},{3}  speed={4} rotation={5} time={6}",
                //    path.Source.X, path.Source.Y, path.Destination.X, path.Destination.Y, path.Speed, path.Angle_Incident, path.Time_Millsecs));                                

                if (checkDuplicate(path))
                {
                    m_buildResult[cannon_name].PathByBullet[bullet_name].Paths.Add(full_path);

                    //SavePath(name, full_path);
                    //Console.WriteLine(string.Format("build finish {0} speed={1} rotation={2}", name, in_speed, in_degree));
                    return;
                }

                pathlist.Add(getKey(path), 0);

                start_x = Convert.ToInt32(path.Destination.X);
                start_y = Convert.ToInt32(path.Destination.Y);
                degree = path.Angle_Reflection;

                full_path.Add(path);
            }
        }

        static void Flush()
        {
            if (!File.Exists(FILE_BULLETPATH))
                return;

            JObject jobj = JObject.Parse(File.ReadAllText(FILE_BULLETPATH));

            JObject node_save = jobj.GetValue("save") as JObject;

            foreach (KeyValuePair<string, CannonPathBundle> path_by_cannon in m_buildResult)
            {
                string name = path_by_cannon.Key;

                foreach (KeyValuePair<string, CannonPathBundle.BulletPathBundle> path_by_bullet in path_by_cannon.Value.PathByBullet)
                {
                    foreach (List<BulletPathInfo> path_by_rotation in path_by_bullet.Value.Paths)
                    {
                        JObject node = new JObject();
                        JArray paths = new JArray();
                        List<BulletPathInfo> pathlist = path_by_rotation;

                        node_save.Add(string.Format("{0}:{1}", name, pathlist[0].Angle_Incident.ToString()), node);

                        node.Add("speed", pathlist[0].Speed.ToString());
                        node.Add("rotation", pathlist[0].Angle_Incident.ToString());
                        node.Add("count", pathlist.Count.ToString());
                        node.Add("path", paths);

                        for (int i = 0; i < pathlist.Count; i++)
                        {
                            BulletPathInfo info = pathlist[i];
                            JObject path_node = new JObject();

                            path_node.Add("x", info.Source.X.ToString());
                            path_node.Add("y", info.Source.Y.ToString());
                            path_node.Add("r", info.Angle_Reflection.ToString());
                            path_node.Add("d", info.Time_Millsecs.ToString());

                            paths.Add(path_node);
                        }
                    }
                }
            }

            File.WriteAllText(FILE_BULLETPATH, jobj.ToString());            
        }
    }
}
